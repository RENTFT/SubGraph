# The set of all the Lending entities is the set of all of the"
# NFTs being lent out on the Rent NFT platform"
type Lending @entity {
  id: ID!
  # Counter of the transaction. Use this for pagination, filtering
  # and sorting.
  cursor: Int!

  nftAddress: Bytes!
  tokenID: BigInt!

  lenderAddress: Bytes!
  maxRentDuration: BigInt!
  dailyRentPrice: Bytes!
  paymentToken: BigInt!
  lendAmount: BigInt!
  availableAmount: BigInt!
  is721: Boolean!
  lentAt: BigInt!

  renting: [Renting!] @derivedFrom(field: "lending")
  user: User!
  nft: Nft!
  rentClaimed: Boolean!
}

type Renting @entity {
  id: ID!
  # Counter of the transaction. Use this for pagination, filtering
  # and sorting.
  cursor: Int!

  renterAddress: Bytes!
  rentAmount: BigInt!
  rentDuration: BigInt!
  rentedAt: BigInt!
  expired: Boolean!
  nft: Nft!
  lending: Lending!
  user: User!
}

type User @entity {
  "id here is user's Ethereum address"
  id: ID!
  # Counter of the transaction. Use this for pagination, filtering
  # and sorting.
  cursor: Int!
  lending: [Lending!] @derivedFrom(field: "user")
  renting: [Renting!] @derivedFrom(field: "user")
}

# How many lendings, rentings, users there were in total
# These are used as cursors to paginate through the result
# set. They are all Ints which makes ordering natural,
# unlike BigInt which is a string (alhpanumeric ordering)
type Counter @entity {
  id: ID!
  lending: Int!
  renting: Int!
  user: Int!
}

# Tracks all of the lending and renting of a single NFT
# same NFT can be re-lent / re-rented multiple times
# This type tracks all of that
# per unique id := lendingId.toString() combination

# 1. Note: you will always have an array of lending
# but not neccesarily an array of renting.
# Renting array is only ever populated if the Nft has been rented.

# 2. Note: that this is a single entity and there will be multiple
# entities. When we make a graphql request, we will be pulling ALL
# such entities

# 3. Also note that when this nftAddress::tokenId::lentAmount unique combo gets
# re-lent by the renter, we push into the lending array. This implies
# that if you have lending.length === renting.length + 1, then the
# nft and tokenId combo are available for lend.
# If, however, lending.length === renting.length, then it is being currently
# rented by someone"
type Nft @entity {
  "id is lendingId.toString()"
  id: ID!

  "each Lending and Renting in the arrays here will have the SAME nftAddress and tokenId!!!!!! As per the id of this entity"
  lending: [Lending!]! @derivedFrom(field: "nft")
  renting: [Renting!] @derivedFrom(field: "nft")
}
